//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ConveyorBelt"
	Revision           = "1.0"
	GUID               = "{3832E229-4C5E-4A07-8C8F-F8A4BB6663E7}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{82EA05CE-E2E4-4350-9163-D59E6FD46D23}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ConveyorbeltSteps" GUID="{E7F39ECA-793A-4D00-BD46-3409C4C17CD2}" Visualized="false" Initialize="true" DefValue="Step01" WriteProtected="false" Retentive="false"/>
		<Server Name="TimeDelay" GUID="{C76F7A38-A46E-424B-AA03-27F167402B28}" Visualized="false" Initialize="true" DefValue="2000" WriteProtected="false" Retentive="File"/>
		<Client Name="Cylinder" Required="true" Internal="false"/>
		<Client Name="Lichtschrank" Required="true" Internal="false"/>
		<Client Name="Motor" Required="true" Internal="false"/>
		<Client Name="Start" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
ConveyorBelt : CLASS
	TYPE
	  t_ConveyorSteps :  //! <Type Public="true" Name="t_ConveyorSteps"/>
	  (
	    Step01:=1,
	    Step02:=2,
	    Step03:=3,
	    Step04:=4
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	TimeDelay 	: SvrCh_UDINT;
	ConveyorbeltSteps 	: SvrCh_t_ConveyorSteps_PTofCls_ConveyorBelt;
  //Clients:
	Motor 	: CltCh_DINT;
	Lichtschrank 	: CltCh_DINT;
	Start 	: CltCh_DINT;
	Cylinder 	: CltCh_DINT;
  //Variables:
		TimeMark 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ConveyorBelt::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CONVEYORBELT
1$UINT, 0$UINT, (SIZEOF(::ConveyorBelt))$UINT, 
3$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3838332719), "ConveyorBelt", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::ConveyorBelt.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::ConveyorBelt.TimeDelay.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(113305410), "TimeDelay", 
(::ConveyorBelt.ConveyorbeltSteps.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3862874476), "ConveyorbeltSteps", 
//Clients:
(::ConveyorBelt.Motor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1007142640), "Motor", 
(::ConveyorBelt.Lichtschrank.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1321777625), "Lichtschrank", 
(::ConveyorBelt.Start.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1747818303), "Start", 
(::ConveyorBelt.Cylinder.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1563936678), "Cylinder", 
END_FUNCTION


#define USER_CNT_ConveyorBelt 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ConveyorBelt] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ConveyorBelt::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_ConveyorBelt, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TimeDelay.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF TimeDelay.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ConveyorbeltSteps.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ConveyorbeltSteps.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL ConveyorBelt::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	vergangenZeit : UDINT;
    vergangenZeitQ : BOOL;
  END_VAR

  
  
  Lichtschrank := Lichtschrank.Read();
  Start := Start.Read();
  
  
  

  //Vergangenzeit
  
  if TimeMark > 0 then
    vergangenZeit := (ops.tAbsolute - TimeMark);
    vergangenZeitQ := vergangenZeit > TimeDelay;
  else
    vergangenZeit := 0;
  end_if;


  
  case ConveyorbeltSteps of
  	ConveyorBelt::t_ConveyorSteps::Step01:  //Start Conveyor
 
 
 //*************Step 01******************\\
      if(Start = 1 AND Lichtschrank = 1) then
        
        Motor := 1;
        Cylinder := 0; 

        TimeMark := ops.tAbsolute;
        ConveyorbeltSteps := Step02;       
        
      elsif(Start = 1 and Lichtschrank = 0) then //Warte auf frei Lichtschrank
        
        Motor := 0;
        Cylinder := 0; 
          
      end_if;


//*************Step 02******************\\
    
  	ConveyorBelt::t_ConveyorSteps::Step02:   //Warte auf Zeit
      
        if vergangenZeitQ then
        
          Cylinder := 1; 
          Motor := 0;
          TimeMark := 0;
          ConveyorbeltSteps := Step03;
        end_if;
      
 
 
 //*************Step 03******************\\
  	ConveyorBelt::t_ConveyorSteps::Step03:  
    
        if Start = 1 and Lichtschrank = 0 then
        
          Cylinder := 1; 
          Motor := 0;
          TimeMark := ops.tAbsolute;
          ConveyorbeltSteps := Step04;
          
        end_if;    
        
        IF Lichtschrank and Lichtschrank = 0 THEN
        
          Lichtschrank := 0;
        END_IF;


//*************Step 04******************\\    
    
  	ConveyorBelt::t_ConveyorSteps::Step04:
    
        if Start = 0  and vergangenZeitQ then
        
          Cylinder := 0; 
          Motor := 0;
          TimeMark := 0;
          ConveyorbeltSteps := Step01;
          
        end_if;   
    
    
  end_case;


  
  Motor.Write (Motor);
  Cylinder.Write (Cylinder);

	state := READY;

END_FUNCTION
